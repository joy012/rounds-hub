import * as FileSystem from 'expo-file-system/legacy';
import * as Print from 'expo-print';
import * as Sharing from 'expo-sharing';
import type { Bed, InvRow, Ward } from './types';

const PDF_HTML_STYLE = `
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: 11px;
      color: #1a1a1a;
      padding: 24px;
      line-height: 1.45;
      max-width: 800px;
      margin: 0 auto;
    }
    .doc-header {
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid #1a1a1a;
    }
    .doc-title {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.05em;
      margin: 0 0 4px 0;
      text-transform: uppercase;
    }
    .doc-subtitle {
      font-size: 12px;
      color: #555;
      margin: 0;
    }
    .doc-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
      font-size: 10px;
      color: #666;
    }
    .bed-block {
      margin-bottom: 28px;
      padding-bottom: 24px;
      border-bottom: 2px solid #c5d4cf;
      page-break-inside: avoid;
    }
    .bed-block:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }
    .patient-block {
      background: #f8faf9;
      border: 1px solid #c5d4cf;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 18px;
    }
    .patient-block-title {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #2d4a42;
      margin: 0 0 10px 0;
      padding-bottom: 6px;
      border-bottom: 1px solid #c5d4cf;
    }
    .patient-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 8px 20px;
    }
    .patient-item {
      display: flex;
      gap: 6px;
    }
    .patient-item strong {
      min-width: 72px;
      font-weight: 600;
      color: #444;
    }
    .section {
      margin-bottom: 18px;
      page-break-inside: avoid;
    }
    .section-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #2d4a42;
      margin: 0 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid #c5d4cf;
    }
    .section-content {
      padding-left: 2px;
    }
    .section-content p {
      margin: 0 0 6px 0;
    }
    .section-content p:last-child {
      margin-bottom: 0;
    }
    .handwriting-img {
      max-width: 100%;
      max-height: 120px;
      object-fit: contain;
      margin-top: 6px;
      background: #fff;
    }
    table.inv-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
      margin-top: 4px;
    }
    table.inv-table th,
    table.inv-table td {
      border: 1px solid #c5d4cf;
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }
    table.inv-table th {
      background: #e8f0ed;
      font-weight: 700;
      color: #2d4a42;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    table.inv-table tr:nth-child(even) {
      background: #fafbfa;
    }
    .inv-cell-img {
      max-width: 140px;
      max-height: 60px;
      object-fit: contain;
      margin-top: 4px;
      background: #fff;
    }
    .footer {
      margin-top: 28px;
      padding-top: 12px;
      border-top: 1px solid #ddd;
      font-size: 9px;
      color: #888;
      text-align: center;
    }
    .muted { color: #666; }
  </style>
`;

function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return text.replace(/[&<>"']/g, (c) => map[c] ?? c);
}

function dataUrl(img: string | undefined): string {
  if (!img?.trim()) return '';
  const raw = img.replace(/\s/g, '');
  return raw.startsWith('data:') ? raw : `data:image/png;base64,${raw}`;
}

const MONTH_SHORT = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec',
];

function formatPrintDate(): string {
  const d = new Date();
  const day = d.getDate();
  const month = MONTH_SHORT[d.getMonth()] ?? '';
  const year = d.getFullYear();
  const h = d.getHours();
  const m = d.getMinutes();
  const pad = (n: number) => String(n).padStart(2, '0');
  return `${day} ${month} ${year}, ${pad(h)}:${pad(m)}`;
}

function buildDocHeader(ward: Ward, bedNumber: number): string {
  const title = escapeHtml(ward.title ?? 'Department');
  const wardNum = escapeHtml(ward.wardNumber ?? '—');
  const printDate = formatPrintDate();
  return `
  <div class="doc-header">
    <h1 class="doc-title">Patient Summary</h1>
    <p class="doc-subtitle">${title} · Ward ${wardNum} · Bed ${bedNumber}</p>
    <div class="doc-meta">
      <span>Document generated by RoundsHub</span>
      <span>Printed: ${escapeHtml(printDate)}</span>
    </div>
  </div>`;
}

function buildPatientBlock(patient: NonNullable<Bed['patient']>, bedNumber: number): string {
  const items: string[] = [];
  items.push(`<div class="patient-item"><strong>Bed No.</strong> ${bedNumber}</div>`);
  if (patient.name)
    items.push(`<div class="patient-item"><strong>Name</strong> ${escapeHtml(patient.name)}</div>`);
  if (patient.age != null)
    items.push(`<div class="patient-item"><strong>Age</strong> ${patient.age}</div>`);
  if (items.length === 0) return '';
  return `
  <div class="patient-block">
    <p class="patient-block-title">Patient details</p>
    <div class="patient-grid">${items.join('')}</div>
  </div>`;
}

function buildDxPlanSection(
  label: string,
  content: { text?: string; image?: string } | undefined
): string {
  if (!content?.text && !content?.image) return '';
  const parts: string[] = [];
  if (content.text) parts.push(`<p>${escapeHtml(content.text)}</p>`);
  if (content.image) {
    const src = dataUrl(content.image);
    if (src) parts.push(`<p><img class="handwriting-img" src="${src}" alt="handwriting" /></p>`);
  }
  return `
  <div class="section">
    <p class="section-title">${escapeHtml(label)}</p>
    <div class="section-content">${parts.join('')}</div>
  </div>`;
}

function invCellContent(text: string | undefined, img: string | undefined): string {
  const t = text?.trim() ? escapeHtml(text) : '<span class="muted">—</span>';
  if (!img?.trim()) return t;
  const src = dataUrl(img);
  return `${t}<br/><img class="inv-cell-img" src="${src}" alt="" />`;
}

function buildInvTable(rows: NonNullable<NonNullable<Bed['patient']>['inv']>): string {
  if (!rows?.length) return '';
  const cells = rows
    .map(
      (r: InvRow) =>
        `<tr>
          <td>${invCellContent(r.date, r.dateImage)}</td>
          <td>${invCellContent(r.investigation, r.investigationImage)}</td>
          <td>${invCellContent(r.findings, r.findingsImage)}</td>
        </tr>`
    )
    .join('');
  return `
  <div class="section">
    <p class="section-title">Investigations</p>
    <table class="inv-table">
      <thead><tr><th>Date</th><th>Investigation</th><th>Findings</th></tr></thead>
      <tbody>${cells}</tbody>
    </table>
  </div>`;
}

function buildFooter(ward: Ward, bedNumber: number): string {
  const title = escapeHtml(ward.title ?? '');
  const wardNum = escapeHtml(ward.wardNumber ?? '');
  return `
  <div class="footer">
    ${title} · Ward ${wardNum} · Bed ${bedNumber} · ${escapeHtml(formatPrintDate())}
  </div>`;
}

export function buildBedPdfHtml(bed: Bed, ward: Ward): string {
  const patient = bed.patient;
  const headerHtml = buildDocHeader(ward, bed.number);
  const patientHtml = patient
    ? buildPatientBlock(patient, bed.number)
    : `<div class="patient-block"><p class="patient-block-title">Patient details</p><div class="patient-grid"><div class="patient-item"><strong>Bed No.</strong> ${bed.number}</div><div class="patient-item"><span class="muted">No patient data</span></div></div></div>`;
  const dxHtml = patient?.dx ? buildDxPlanSection('Diagnosis', patient.dx) : '';
  const planHtml = patient?.plan ? buildDxPlanSection('Plan', patient.plan) : '';
  const invHtml = patient?.inv ? buildInvTable(patient.inv) : '';

  return `
  <!DOCTYPE html>
  <html>
  <head><meta charset="utf-8"/>${PDF_HTML_STYLE}</head>
  <body>
    ${headerHtml}
    ${patientHtml}
    ${dxHtml}
    ${invHtml}
    ${planHtml}
  </body>
  </html>`;
}

function sanitizeFilenamePart(s: string, maxLen = 40): string {
  return s
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, maxLen);
}

export function getBedPdfFilename(bed: Bed, ward: Ward): string {
  const department = sanitizeFilenamePart(ward.title ?? 'Department');
  const wardNum = (ward.wardNumber ?? '').replace(/\s+/g, '-') || '0';
  const bedNum = String(bed.number);
  const date = new Date().toISOString().slice(0, 10);
  const patientName = bed.patient?.name?.trim();
  const namePart = patientName ? `-${sanitizeFilenamePart(patientName, 30)}` : '';
  return `${department}-Ward${wardNum}-Bed${bedNum}${namePart}-${date}.pdf`;
}

export async function exportBedToPdf(bed: Bed, ward: Ward): Promise<void> {
  const html = buildBedPdfHtml(bed, ward);

  const { uri } = await Print.printToFileAsync({
    html,
    base64: false,
  });

  const filename = getBedPdfFilename(bed, ward);
  const docDir = FileSystem.documentDirectory;
  if (!docDir) {
    throw new Error('Document directory is not available');
  }
  const destUri = docDir.endsWith('/') ? `${docDir}${filename}` : `${docDir}/${filename}`;

  let shareUri = destUri;
  try {
    await FileSystem.copyAsync({ from: uri, to: destUri });
  } catch {
    shareUri = uri;
  }

  const canShare = await Sharing.isAvailableAsync();
  if (!canShare) {
    throw new Error('Sharing is not available on this device');
  }

  await Sharing.shareAsync(shareUri, {
    mimeType: 'application/pdf',
    dialogTitle: 'Save PDF',
  });
}

function buildWardSummaryPdfHtml(ward: Ward): string {
  const date = new Date().toISOString().slice(0, 10);
  const printDate = formatPrintDate();
  const title = escapeHtml(ward.title ?? 'Ward');
  const wardNum = escapeHtml(ward.wardNumber ?? '');

  const bedBlocks = ward.beds
    .map((bed) => {
      const patient = bed.patient;
      const name = escapeHtml(patient?.name?.trim() ?? '—');
      const patientLine =
        `<div class="patient-block">
    <p class="patient-block-title">Bed ${bed.number} · ${name}</p>
    <div class="patient-grid">
      <div class="patient-item"><strong>Bed</strong> ${bed.number}</div>
      <div class="patient-item"><strong>Patient</strong> ${name}</div>
    </div>
  </div>`;

      const diagnosisHtml = patient?.dx
        ? buildDxPlanSection('Diagnosis', patient.dx)
        : '<div class="section"><p class="section-title">Diagnosis</p><div class="section-content"><p class="muted">—</p></div></div>';
      const invHtml = patient?.inv?.length
        ? buildInvTable(patient.inv)
        : '<div class="section"><p class="section-title">Investigations</p><div class="section-content"><p class="muted">—</p></div></div>';
      const planHtml = patient?.plan
        ? buildDxPlanSection('Plan', patient.plan)
        : '<div class="section"><p class="section-title">Plan</p><div class="section-content"><p class="muted">—</p></div></div>';

      return `<div class="bed-block">${patientLine}${diagnosisHtml}${invHtml}${planHtml}</div>`;
    })
    .join('');

  const docHeader = `
  <div class="doc-header">
    <h1 class="doc-title">Ward Summary</h1>
    <p class="doc-subtitle">${title} · Ward ${wardNum}</p>
    <div class="doc-meta">
      <span>Document generated by RoundsHub</span>
      <span>Printed: ${escapeHtml(printDate)}</span>
    </div>
  </div>`;

  return `
  <!DOCTYPE html>
  <html>
  <head><meta charset="utf-8"/>${PDF_HTML_STYLE}</head>
  <body>
    ${docHeader}
    ${bedBlocks}
    <div class="footer">
      ${title} · Ward ${wardNum} · ${escapeHtml(printDate)} · Ward summary
    </div>
  </body>
  </html>`;
}

export function getWardSummaryPdfFilename(ward: Ward): string {
  const department = sanitizeFilenamePart(ward.title ?? 'Ward');
  const wardNum = (ward.wardNumber ?? '').replace(/\s+/g, '-') || '0';
  const date = new Date().toISOString().slice(0, 10);
  return `RoundsHub-ward-${department}-${wardNum}-${date}.pdf`;
}

export async function exportWardSummaryPdf(ward: Ward): Promise<void> {
  const html = buildWardSummaryPdfHtml(ward);
  const { uri } = await Print.printToFileAsync({ html, base64: false });
  const filename = getWardSummaryPdfFilename(ward);
  const docDir = FileSystem.documentDirectory;
  if (!docDir) throw new Error('Document directory is not available');
  const destUri = docDir.endsWith('/') ? `${docDir}${filename}` : `${docDir}/${filename}`;
  let shareUri = destUri;
  try {
    await FileSystem.copyAsync({ from: uri, to: destUri });
  } catch {
    shareUri = uri;
  }
  const canShare = await Sharing.isAvailableAsync();
  if (!canShare) throw new Error('Sharing is not available on this device');
  await Sharing.shareAsync(shareUri, { mimeType: 'application/pdf', dialogTitle: 'Save ward PDF' });
}

// --- Sketch PDF (drawing pad export) ---

function buildSketchPdfHtml(title: string, imageBase64: string | undefined): string {
  const printDate = formatPrintDate();
  const safeTitle = escapeHtml(title?.trim() || 'Untitled sketch');
  const imgSrc = dataUrl(imageBase64);
  const imgHtml = imgSrc
    ? `<img src="${imgSrc}" alt="Sketch" style="max-width:100%; height:auto; display:block; margin:0 auto; background:#fff;" />`
    : '<p class="muted">No drawing</p>';
  return `
  <!DOCTYPE html>
  <html>
  <head><meta charset="utf-8"/>${PDF_HTML_STYLE}</head>
  <body>
    <div class="doc-header">
      <h1 class="doc-title">${safeTitle}</h1>
      <p class="doc-subtitle">RoundsHub · Sketch</p>
      <div class="doc-meta">
        <span>Printed: ${escapeHtml(printDate)}</span>
      </div>
    </div>
    <div class="section">
      <div class="section-content">${imgHtml}</div>
    </div>
    <div class="footer">${safeTitle} · ${escapeHtml(printDate)}</div>
  </body>
  </html>`;
}

export function getSketchPdfFilename(title: string): string {
  const safe = (title?.trim() || 'sketch').replace(/[^a-zA-Z0-9-_ ]/g, '').replace(/\s+/g, '-').slice(0, 40) || 'sketch';
  const date = new Date().toISOString().slice(0, 10);
  return `RoundsHub-sketch-${safe}-${date}.pdf`;
}

export async function exportSketchToPdf(title: string, imageBase64: string | undefined): Promise<void> {
  const html = buildSketchPdfHtml(title, imageBase64);
  // useMarkupFormatter: false so the WebView path is used and base64 images render in the PDF (iOS UIMarkupTextPrintFormatter doesn't display images)
  const { uri } = await Print.printToFileAsync({ html, base64: false, useMarkupFormatter: false });
  const filename = getSketchPdfFilename(title);
  const docDir = FileSystem.documentDirectory;
  if (!docDir) throw new Error('Document directory is not available');
  const destUri = docDir.endsWith('/') ? `${docDir}${filename}` : `${docDir}/${filename}`;
  let shareUri = destUri;
  try {
    await FileSystem.copyAsync({ from: uri, to: destUri });
  } catch {
    shareUri = uri;
  }
  const canShare = await Sharing.isAvailableAsync();
  if (!canShare) throw new Error('Sharing is not available on this device');
  await Sharing.shareAsync(shareUri, { mimeType: 'application/pdf', dialogTitle: 'Save sketch PDF' });
}

/** Share sketch as PNG image (reliable; use when PDF export shows empty). */
export async function shareSketchAsImage(title: string, imageBase64: string | undefined): Promise<void> {
  if (!imageBase64?.trim()) throw new Error('No drawing to share');
  const raw = imageBase64.replace(/\s/g, '');
  const base64Only = raw.startsWith('data:') ? raw.replace(/^data:image\/\w+;base64,/, '') : raw;
  if (!base64Only) throw new Error('Invalid image data');
  const docDir = FileSystem.documentDirectory;
  if (!docDir) throw new Error('Document directory is not available');
  const safe = (title?.trim() || 'sketch').replace(/[^a-zA-Z0-9-_ ]/g, '').replace(/\s+/g, '-').slice(0, 40) || 'sketch';
  const date = new Date().toISOString().slice(0, 10);
  const filename = `RoundsHub-sketch-${safe}-${date}.png`;
  const fileUri = docDir.endsWith('/') ? `${docDir}${filename}` : `${docDir}/${filename}`;
  await FileSystem.writeAsStringAsync(fileUri, base64Only, {
    encoding: FileSystem.EncodingType.Base64,
  });
  const canShare = await Sharing.isAvailableAsync();
  if (!canShare) throw new Error('Sharing is not available on this device');
  await Sharing.shareAsync(fileUri, { mimeType: 'image/png', dialogTitle: 'Save sketch' });
}
